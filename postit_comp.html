<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Sticky Notes 메모장</title><style> body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; height: 100vh; overflow: hidden; background-color: #f0f0f0; } .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; justify-content: center; align-items: center; } .modal-content { background-color: white; padding: 20px; border-radius: 8px; width: 300px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } .modal-title { margin-bottom: 15px; font-size: 18px; font-weight: bold; } .modal-input { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; } .modal-actions { display: flex; justify-content: flex-end; gap: 10px; } .modal-btn { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; } .modal-btn.confirm { background-color: #4a90e2; color: white; } .modal-btn.cancel { background-color: #f0f0f0; } #header { display: flex; padding: 10px; background-color: #ffffff; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); align-items: center; gap: 10px; z-index: 200; } #canvas-select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; min-width: 150px; } #canvas-title { padding: 8px; border: 1px solid #ddd; border-radius: 4px; flex-grow: 1; max-width: 200px; } .header-btn { padding: 8px 12px; border: none; border-radius: 4px; background-color: #4a90e2; color: white; cursor: pointer; transition: background-color 0.2s; } .header-btn:hover { background-color: #357abd; } .header-btn.danger { background-color: #e74c3c; } .header-btn.danger:hover { background-color: #c0392b; } #canvas-container { position: absolute; width: 100%; height: calc(100vh - 80px); overflow: hidden; background-color: #f5f5f5; background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px); background-size: 20px 20px; background-position: center; transition: transform 0.3s ease; touch-action: none; user-select: none; } #canvas { position: absolute; width: 100%; height: 100%; transform-origin: 0 0; cursor: default; pointer-events: none; } .note { position: absolute; width: 200px; min-height: 200px; padding: 15px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); border-radius: 2px; display: flex; flex-direction: column; transition: box-shadow 0.3s ease; cursor: grab; resize: none; overflow: hidden; pointer-events: auto; } .note:hover { box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); } .note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid rgba(0, 0, 0, 0.1); } .note-type { font-size: 12px; font-weight: bold; text-transform: uppercase; } .note-actions { display: flex; gap: 5px; } .note-actions button { background: none; border: none; cursor: pointer; font-size: 12px; opacity: 0.5; transition: opacity 0.2s; } .note-actions button:hover { opacity: 1; } .note-content { flex-grow: 1; outline: none; overflow-wrap: break-word; resize: none; border: none; background: transparent; font-family: inherit; font-size: 14px; line-height: 1.4; margin-bottom: 10px; overflow: auto; } .note-footer { font-size: 10px; color: rgba(0, 0, 0, 0.5); text-align: right; position: relative; padding-right: 10px; } .resize-handle { position: absolute; right: -15px; bottom: -15px; width: 10px; height: 10px; background-color: rgba(240, 18, 18, 0.932); cursor: nwse-resize; border-radius: 2px; } #add-note-btn { position: fixed; bottom: 70px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background-color: #ffeb3b; border: none; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); font-size: 24px; cursor: pointer; z-index: 100; } #add-note-btn:hover { background-color: #fdd835; } #zoom-controls { position: fixed; bottom: 130px; right: 20px; display: flex; flex-direction: column; gap: 5px; z-index: 100; } .zoom-btn { width: 40px; height: 40px; border-radius: 50%; background-color: white; border: none; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; } .zoom-btn:hover { background-color: #f5f5f5; } #zoom-level { position: fixed; bottom: 180px; right: 30px; background-color: white; padding: 5px 10px; border-radius: 20px; font-size: 12px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 100; } #context-menu { position: absolute; display: none; background-color: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); z-index: 1000; min-width: 150px; } .context-menu-item { padding: 8px 12px; cursor: pointer; font-size: 14px; } .context-menu-item:hover { background-color: #f5f5f5; } .context-menu-divider { height: 1px; background-color: #eee; margin: 4px 0; } #search-container { display: flex; align-items: center; gap: 5px; margin-left: 10px; } #search-input { padding: 8px; border: 1px solid #ddd; border-radius: 4px; width: 150px; } .search-btn { padding: 8px 12px; border: none; border-radius: 4px; background-color: #4a90e2; color: white; cursor: pointer; transition: background-color 0.2s; } .search-btn:hover { background-color: #357abd; } .search-btn:disabled { background-color: #cccccc; cursor: not-allowed; } .note.highlighted { box-shadow: 0 0 0 3px #ff5722; animation: pulse 0.5s; } @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } } #opacity-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 30px; background-color: #ffffff; display: flex; align-items: center; padding: 0 20px; box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); z-index: 100; } #opacity-slider { flex-grow: 1; margin: 0 10px; } #opacity-value { width: 40px; text-align: center; font-size: 12px; } </style></head><body><div id="header"><select id="canvas-select"></select><input type="text" id="canvas-title" placeholder="캔버스 제목"><button id="save-canvas-btn" class="header-btn">캔버스 저장</button><button id="new-canvas-btn" class="header-btn">새 캔버스</button><button id="clear-canvas-btn" class="header-btn">캔버스 비우기</button><button id="delete-canvas-btn" class="header-btn danger">캔버스 삭제</button><button id="export-btn" class="header-btn">파일로 내보내기</button><button id="import-btn" class="header-btn">파일 불러오기</button><div id="search-container"><input type="text" id="search-input" placeholder="검색어 입력"><button id="search-btn" class="search-btn">검색</button><button id="prev-btn" class="search-btn" disabled>이전</button><button id="next-btn" class="search-btn" disabled>다음</button></div></div><div id="new-canvas-modal" class="modal"><div class="modal-content"><div class="modal-title">새 캔버스 제목 입력</div><input type="text" id="new-canvas-title" class="modal-input" placeholder="캔버스 제목을 입력하세요"><div class="modal-actions"><button id="cancel-new-canvas" class="modal-btn cancel">취소</button><button id="confirm-new-canvas" class="modal-btn confirm">생성</button></div></div></div><div id="canvas-container"><div id="canvas"></div></div><div id="opacity-controls"><span>투명도:</span><input type="range" id="opacity-slider" min="30" max="100" value="100"><span id="opacity-value">100%</span></div><div id="zoom-controls"><button class="zoom-btn" id="zoom-in">+</button><button class="zoom-btn" id="zoom-out">-</button><button class="zoom-btn" id="zoom-reset">↻</button></div><div id="zoom-level">100%</div><button id="add-note-btn">+</button><div id="context-menu"><div class="context-menu-item" id="context-add-note">메모 추가</div><div class="context-menu-divider"></div><div class="context-menu-item" id="context-align-notes">시작점 정렬</div></div><script> const noteTypes = { default: '#ffeb3b', important: '#ff8a65', idea: '#81d4fa', reminder: '#ce93d8', personal: '#a5d6a7' }; const defaultNoteType = 'default'; const defaultNotePosition = { left: '50%', top: '50%' }; document.addEventListener('DOMContentLoaded', () => { const canvasContainer = document.getElementById('canvas-container'); const canvas = document.getElementById('canvas'); const addNoteBtn = document.getElementById('add-note-btn'); const zoomInBtn = document.getElementById('zoom-in'); const zoomOutBtn = document.getElementById('zoom-out'); const zoomResetBtn = document.getElementById('zoom-reset'); const zoomLevelDisplay = document.getElementById('zoom-level'); const canvasSelect = document.getElementById('canvas-select'); const canvasTitleInput = document.getElementById('canvas-title'); const saveCanvasBtn = document.getElementById('save-canvas-btn'); const exportBtn = document.getElementById('export-btn'); const importBtn = document.getElementById('import-btn'); const newCanvasModal = document.getElementById('new-canvas-modal'); const newCanvasTitleInput = document.getElementById('new-canvas-title'); const confirmNewCanvasBtn = document.getElementById('confirm-new-canvas'); const cancelNewCanvasBtn = document.getElementById('cancel-new-canvas'); const contextMenu = document.getElementById('context-menu'); const contextAddNote = document.getElementById('context-add-note'); const contextAlignNotes = document.getElementById('context-align-notes'); let lastRightClickPosition = { x: 0, y: 0 }; const searchInput = document.getElementById('search-input'); const searchBtn = document.getElementById('search-btn'); const prevBtn = document.getElementById('prev-btn'); const nextBtn = document.getElementById('next-btn'); const opacitySlider = document.getElementById('opacity-slider'); const opacityValue = document.getElementById('opacity-value'); let isDraggingCanvas = false; let dragStartX = 0; let dragStartY = 0; let searchResults = []; let currentSearchIndex = -1; let currentSearchTerm = ''; let scale = 1; let translateX = 0; let translateY = 0; let currentCanvasId = null; let canvases = {}; init(); function init() { translateX = 0; translateY = 0; scale = 1; isDraggingCanvas = false; loadCanvasesFromLocalStorage(); updateCanvasSelect(); if (Object.keys(canvases).length === 0) { showNewCanvasModal(); } else { const firstCanvasId = Object.keys(canvases)[0]; loadCanvas(firstCanvasId); } setupEventListeners(); setupContextMenu(); setupSearch(); setupOpacityControls(); setupCanvasDrag(); updateTransform(); document.addEventListener('click', (e) => { if (!e.target.closest('#context-menu') && !e.target.closest('#search-container') && !e.target.closest('.note.highlighted')) { clearHighlights(); updateSearchButtons(); } }); } function setupCanvasDrag() { const canvasContainer = document.getElementById('canvas-container'); canvasContainer.addEventListener('mousedown', (e) => { if (!e.target.classList.contains('note') && e.target === canvasContainer) { isDraggingCanvas = true; dragStartX = e.clientX - translateX; dragStartY = e.clientY - translateY; canvasContainer.style.cursor = 'grabbing'; e.preventDefault(); console.log("드래그 시작", dragStartX, dragStartY); } }); document.addEventListener('mousemove', (e) => { if (!isDraggingCanvas) return; translateX = e.clientX - dragStartX; translateY = e.clientY - dragStartY; updateTransform(); }); document.addEventListener('mouseup', () => { isDraggingCanvas = false; canvasContainer.style.cursor = 'default'; }); canvasContainer.addEventListener('touchstart', (e) => { if (e.target !== canvasContainer) return; isDraggingCanvas = true; const touch = e.touches[0]; dragStartX = touch.clientX - translateX; dragStartY = touch.clientY - translateY; e.preventDefault(); }); document.addEventListener('touchmove', (e) => { if (!isDraggingCanvas) return; const touch = e.touches[0]; translateX = touch.clientX - dragStartX; translateY = touch.clientY - dragStartY; updateTransform(); e.preventDefault(); }); document.addEventListener('touchend', () => { isDraggingCanvas = false; }); } function setupOpacityControls() { opacitySlider.addEventListener('input', () => { const opacity = opacitySlider.value; opacityValue.textContent = `${opacity}%`; document.querySelectorAll('.note').forEach(note => { note.style.opacity = opacity / 100; }); if (currentCanvasId) { canvases[currentCanvasId].opacity = opacity / 100; saveCurrentCanvas(); } }); } function showNewCanvasModal() { newCanvasTitleInput.value = ''; newCanvasModal.style.display = 'flex'; newCanvasTitleInput.focus(); } function setupEventListeners() { addNoteBtn.addEventListener('click', () => { createNote(); }); document.getElementById('new-canvas-btn').addEventListener('click', () => { createNewCanvas(); }); document.getElementById('delete-canvas-btn').addEventListener('click', () => { if (!currentCanvasId) return; if (confirm('정말로 이 캔버스를 삭제하시겠습니까? 삭제 후 복구할 수 없습니다.')) { deleteCanvas(currentCanvasId); } }); document.getElementById('clear-canvas-btn').addEventListener('click', () => { if (!currentCanvasId) return; if (confirm('현재 캔버스의 모든 메모를 삭제하시겠습니까?')) { clearCurrentCanvas(); } }); document.getElementById('new-canvas-btn').addEventListener('click', () => { showNewCanvasModal(); }); confirmNewCanvasBtn.addEventListener('click', () => { const title = newCanvasTitleInput.value.trim(); if (title) { createNewCanvas(title); newCanvasModal.style.display = 'none'; } else { alert('캔버스 제목을 입력해주세요.'); } }); cancelNewCanvasBtn.addEventListener('click', () => { newCanvasModal.style.display = 'none'; if (Object.keys(canvases).length === 0) { createNewCanvas('새 캔버스'); } }); newCanvasModal.addEventListener('click', (e) => { if (e.target === newCanvasModal) { newCanvasModal.style.display = 'none'; if (Object.keys(canvases).length === 0) { createNewCanvas('새 캔버스'); } } }); canvasTitleInput.addEventListener('change', () => { if (!currentCanvasId) return; const newTitle = canvasTitleInput.value.trim(); if (!newTitle) return; if (newTitle !== canvases[currentCanvasId].title) { saveAsNewCanvas(newTitle); } }); zoomInBtn.addEventListener('click', () => { zoom(1.1); }); zoomOutBtn.addEventListener('click', () => { zoom(0.9); }); zoomResetBtn.addEventListener('click', () => { resetZoom(); }); canvasSelect.addEventListener('change', (e) => { if (e.target.value) { loadCanvas(e.target.value); } }); saveCanvasBtn.addEventListener('click', () => { saveCurrentCanvas(); }); exportBtn.addEventListener('click', () => { exportCanvases(); }); importBtn.addEventListener('click', () => { importCanvases(); }); } function zoom(factor) { scale *= factor; updateTransform(); updateZoomLevel(); } function resetZoom() { scale = 1; translateX = 0; translateY = 0; updateTransform(); updateZoomLevel(); } function updateTransform() { const canvas = document.getElementById('canvas'); canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; console.log("현재 위치:", translateX, translateY); } function updateZoomLevel() { zoomLevelDisplay.textContent = `${Math.round(scale * 100)}%`; } function loadCanvasesFromLocalStorage() { const savedCanvases = localStorage.getItem('stickyNotesCanvases'); if (savedCanvases) { canvases = JSON.parse(savedCanvases); } } function updateCanvasSelect() { canvasSelect.innerHTML = ''; Object.keys(canvases).forEach(canvasId => { const option = document.createElement('option'); option.value = canvasId; option.textContent = canvases[canvasId].title || `캔버스 ${canvasId}`; canvasSelect.appendChild(option); }); if (currentCanvasId) { canvasSelect.value = currentCanvasId; } } function createNewCanvas(title) { if (!title || !title.trim()) { alert('캔버스 제목을 입력해주세요.'); return null; } const newCanvasId = Date.now().toString(); currentCanvasId = newCanvasId; canvases[newCanvasId] = { id: newCanvasId, title: title.trim(), notes: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), opacity: 1 }; updateCanvasSelect(); canvasTitleInput.value = title.trim(); opacitySlider.value = 100; opacityValue.textContent = '100%'; clearCanvas(); localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); return newCanvasId; } function loadCanvas(canvasId) { if (!canvases[canvasId]) return; currentCanvasId = canvasId; const canvasData = canvases[canvasId]; canvasTitleInput.value = canvasData.title || ''; const opacity = canvasData.opacity !== undefined ? canvasData.opacity : 1; opacitySlider.value = opacity * 100; opacityValue.textContent = `${opacity * 100}%`; clearCanvas(); if (canvasData.notes && canvasData.notes.length > 0) { canvasData.notes.forEach(note => { createNote( note.content, note.type, note.position, note.id, note.size, note.opacity ); }); } updateCanvasSelect(); } function saveCurrentCanvas() { if (!currentCanvasId) return; const title = canvasTitleInput.value.trim(); canvases[currentCanvasId].title = title; canvases[currentCanvasId].updatedAt = new Date().toISOString(); canvases[currentCanvasId].opacity = parseFloat(opacitySlider.value) / 100; const notes = []; const noteElements = document.querySelectorAll('.note'); noteElements.forEach(note => { notes.push({ id: note.id, content: note.querySelector('.note-content').value, type: note.querySelector('.note-type').textContent, position: { left: note.style.left, top: note.style.top }, size: { width: note.style.width, height: note.style.height }, opacity: parseFloat(note.style.opacity || '1'), createdAt: note.querySelector('.note-footer').textContent }); }); canvases[currentCanvasId].notes = notes; localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); updateCanvasSelect(); } function clearCanvas() { canvas.innerHTML = ''; } function setupContextMenu() { canvasContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); lastRightClickPosition = { x: e.clientX, y: e.clientY }; contextMenu.style.display = 'block'; contextMenu.style.left = `${e.clientX}px`; contextMenu.style.top = `${e.clientY}px`; }); document.addEventListener('click', () => { contextMenu.style.display = 'none'; }); contextAddNote.addEventListener('click', () => { createNoteAtPosition(lastRightClickPosition); contextMenu.style.display = 'none'; }); contextAlignNotes.addEventListener('click', () => { alignNotesFromPosition(lastRightClickPosition); contextMenu.style.display = 'none'; }); } function createNoteAtPosition(position) { if (!currentCanvasId) return; const containerRect = canvasContainer.getBoundingClientRect(); const x = position.x - containerRect.left - translateX; const y = position.y - containerRect.top - translateY; const scaledX = x / scale; const scaledY = y / scale; const noteId = createNote('', defaultNoteType, { left: `${scaledX}px`, top: `${scaledY}px` }); saveCurrentCanvas(); return noteId; } function alignNotesFromPosition(startPosition) { if (!currentCanvasId || !canvases[currentCanvasId] || !canvases[currentCanvasId].notes) return; const containerRect = canvasContainer.getBoundingClientRect(); const startX = (startPosition.x - containerRect.left - translateX) / scale; const startY = (startPosition.y - containerRect.top - translateY) / scale; const noteWidth = 200; const noteHeight = 200; const margin = 20; const notes = [...canvases[currentCanvasId].notes]; notes.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt)); const noteElements = Array.from(document.querySelectorAll('.note')); notes.forEach((note, index) => { const noteElement = noteElements.find(el => el.id === note.id); if (!noteElement) return; const row = Math.floor(index / 5); const col = index % 5; const x = startX + col * (noteWidth + margin); const y = startY + row * (noteHeight + margin); noteElement.style.left = `${x}px`; noteElement.style.top = `${y}px`; note.position = { left: `${x}px`, top: `${y}px` }; }); canvases[currentCanvasId].notes = notes; saveCurrentCanvas(); } function createNote(content = '', type = defaultNoteType, position = null, noteId = null, size = null, noteOpacity = null) { noteId = noteId || Date.now().toString(); const note = document.createElement('div'); note.className = 'note'; note.id = noteId; note.style.backgroundColor = noteTypes[type] || noteTypes[defaultNoteType]; const opacity = noteOpacity !== null ? noteOpacity : parseFloat(opacitySlider.value) / 100; note.style.opacity = opacity; if (position) { note.style.left = position.left; note.style.top = position.top; } else { const canvasRect = canvas.getBoundingClientRect(); note.style.left = `${canvasRect.width / 2 - 100}px`; note.style.top = `${canvasRect.height / 2 - 100}px`; } if (size && size.width && size.height) { note.style.width = size.width; note.style.height = size.height; } else { note.style.width = '200px'; note.style.height = '200px'; } note.innerHTML = ` <div class="note-header"><span class="note-type">${type}</span><div class="note-actions"><button class="change-type-btn">✏️</button><button class="delete-btn">🗑️</button></div></div><textarea class="note-content" placeholder="메모를 입력하세요...">${content}</textarea><div class="note-footer">${new Date().toLocaleDateString()} <div class="resize-handle"></div></div> `; canvas.appendChild(note); makeDraggable(note); setupResizeHandle(note); const deleteBtn = note.querySelector('.delete-btn'); const changeTypeBtn = note.querySelector('.change-type-btn'); const noteContent = note.querySelector('.note-content'); deleteBtn.addEventListener('click', () => { deleteNote(noteId); }); changeTypeBtn.addEventListener('click', () => { changeNoteType(noteId); }); noteContent.addEventListener('input', () => { if (currentCanvasId) { saveCurrentCanvas(); } }); return noteId; } function makeDraggable(note) { let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; let isDragging = false; function dragMouseDown(e) { if (e.target.classList.contains('resize-handle')) { return; } if (e.target.tagName === 'TEXTAREA') { return; } e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; note.style.cursor = 'grabbing'; isDragging = true; } function elementDrag(e) { if (!isDragging) return; e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; const currentLeft = parseFloat(note.style.left || '0'); const currentTop = parseFloat(note.style.top || '0'); note.style.left = (currentLeft - pos1 / scale) + "px"; note.style.top = (currentTop - pos2 / scale) + "px"; if (currentCanvasId) { saveCurrentCanvas(); } } function closeDragElement() { document.onmouseup = null; document.onmousemove = null; note.style.cursor = 'grab'; isDragging = false; } note.onmousedown = dragMouseDown; } function setupResizeHandle(note) { const resizeHandle = note.querySelector('.resize-handle'); let startX, startY, startWidth, startHeight; resizeHandle.addEventListener('mousedown', initResize); function initResize(e) { e.preventDefault(); e.stopPropagation(); startX = e.clientX; startY = e.clientY; startWidth = parseInt(document.defaultView.getComputedStyle(note).width, 10); startHeight = parseInt(document.defaultView.getComputedStyle(note).height, 10); document.onmousemove = resize; document.onmouseup = stopResize; } function resize(e) { const minWidth = 100; const minHeight = 100; let newWidth = startWidth + (e.clientX - startX) / scale; let newHeight = startHeight + (e.clientY - startY) / scale; newWidth = Math.max(newWidth, minWidth); newHeight = Math.max(newHeight, minHeight); note.style.width = `${newWidth}px`; note.style.height = `${newHeight}px`; } function stopResize() { document.onmousemove = null; document.onmouseup = null; if (currentCanvasId) { saveCurrentCanvas(); } } } function changeNoteType(noteId) { const note = document.getElementById(noteId); if (!note) return; const currentType = note.querySelector('.note-type').textContent; const types = Object.keys(noteTypes); const currentIndex = types.indexOf(currentType); const nextIndex = (currentIndex + 1) % types.length; const nextType = types[nextIndex]; note.querySelector('.note-type').textContent = nextType; note.style.backgroundColor = noteTypes[nextType]; if (currentCanvasId) { saveCurrentCanvas(); } } function setupSearch() { searchBtn.addEventListener('click', () => { console.log('검색버튼 누름'); const term = searchInput.value.trim(); if (term) { searchNotes(term); } }); prevBtn.addEventListener('click', () => { console.log('이전버튼 누름'); navigateSearchResult(-1); }); nextBtn.addEventListener('click', () => { console.log('다음버튼 누름'); navigateSearchResult(1); }); searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { const term = searchInput.value.trim(); if (term) { searchNotes(term); } } }); } function clearHighlights() { document.querySelectorAll('.note.highlighted').forEach(note => { note.classList.remove('highlighted'); }); } function searchNotes(term) { if (!currentCanvasId || !canvases[currentCanvasId]) return; clearHighlights(); currentSearchTerm = term; searchResults = []; const notes = canvases[currentCanvasId].notes; notes.forEach(note => { const noteElement = document.getElementById(note.id); if (noteElement && note.content.includes(term)) { searchResults.push(note.id); } }); if (searchResults.length > 0) { currentSearchIndex = 0; highlightNote(searchResults[currentSearchIndex]); centerNote(searchResults[currentSearchIndex]); updateSearchButtons(); } else { alert('검색어와 일치하는 메모를 찾을 수 없습니다.'); currentSearchIndex = -1; updateSearchButtons(); } console.log('검색 결과 배열:', searchResults); } function navigateSearchResult(direction) { if (searchResults.length === 0) return; clearHighlights(); console.log('currentSearchIndex : '+ currentSearchIndex); console.log('추가할 숫자 : '+ direction); currentSearchIndex += direction; console.log('이동할 순번 : '+ currentSearchIndex); console.log('searchResults.length : '+ searchResults.length); if (currentSearchIndex >= searchResults.length) { currentSearchIndex = 0; } else if (currentSearchIndex < 0) { currentSearchIndex = searchResults.length - 1; } highlightNote(searchResults[currentSearchIndex]); centerNote(searchResults[currentSearchIndex]); updateSearchButtons(); } function highlightNote(noteId) { const note = document.getElementById(noteId); if (note) { note.classList.add('highlighted'); } } function centerNote(noteId) { const note = document.getElementById(noteId); if (!note) return; const noteRect = note.getBoundingClientRect(); const containerRect = canvasContainer.getBoundingClientRect(); const noteCenterX = noteRect.left + noteRect.width / 2; const noteCenterY = noteRect.top + noteRect.height / 2; const containerCenterX = containerRect.width / 2; const containerCenterY = containerRect.height / 2; const moveX = containerCenterX - noteCenterX; const moveY = containerCenterY - noteCenterY; translateX += moveX; translateY += moveY; updateTransform(); } function updateSearchButtons() { prevBtn.disabled = searchResults.length === 0; nextBtn.disabled = searchResults.length === 0; if (searchInput.value.trim() !== currentSearchTerm) { searchBtn.disabled = false; prevBtn.disabled = true; nextBtn.disabled = true; } else { searchBtn.disabled = false; } } function saveAsNewCanvas(title) { if (!currentCanvasId) return; const oldCanvas = canvases[currentCanvasId]; const newCanvasId = Date.now().toString(); canvases[newCanvasId] = { id: newCanvasId, title: title, notes: JSON.parse(JSON.stringify(oldCanvas.notes)), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), opacity: parseFloat(opacitySlider.value) / 100 }; currentCanvasId = newCanvasId; localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); updateCanvasSelect(); canvasTitleInput.value = title; alert('새 캔버스로 저장되었습니다.'); } function deleteCanvas(canvasId) { if (!canvases[canvasId]) return; delete canvases[canvasId]; localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); if (Object.keys(canvases).length > 0) { const firstCanvasId = Object.keys(canvases)[0]; loadCanvas(firstCanvasId); } else { createNewCanvas(); } updateCanvasSelect(); } function clearCurrentCanvas() { if (!currentCanvasId) return; clearCanvas(); canvases[currentCanvasId].notes = []; canvases[currentCanvasId].updatedAt = new Date().toISOString(); localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); } function deleteNote(noteId) { const note = document.getElementById(noteId); if (note) { note.remove(); if (currentCanvasId) { saveCurrentCanvas(); } } } function exportCanvases() { if (Object.keys(canvases).length === 0) { alert('내보낼 캔버스가 없습니다.'); return; } const dataStr = JSON.stringify(canvases, null, 2); const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr); const exportFileDefaultName = `sticky-notes-${new Date().toISOString().slice(0, 10)}.json`; const linkElement = document.createElement('a'); linkElement.setAttribute('href', dataUri); linkElement.setAttribute('download', exportFileDefaultName); linkElement.click(); } function importCanvases() { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = event => { try { const importedCanvases = JSON.parse(event.target.result); canvases = { ...canvases, ...importedCanvases }; localStorage.setItem('stickyNotesCanvases', JSON.stringify(canvases)); updateCanvasSelect(); const firstCanvasId = Object.keys(importedCanvases)[0]; loadCanvas(firstCanvasId); alert('캔버스 데이터가 성공적으로 불러와졌습니다.'); } catch (error) { alert('파일을 읽는 중 오류가 발생했습니다: ' + error.message); } }; reader.readAsText(file); }; input.click(); } }); </script></body></html>