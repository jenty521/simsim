<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="웹 다이어그램 생성 ( WEB DIAGRAM MAKER )">
    <title>웹 다이어그램 생성 ( WEB DIAGRAM MAKER )</title>
	<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7NY0VN0ECJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7NY0VN0ECJ');
</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4624141391435876"
     crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
		
		.color-picker-wrapper {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.color-preview {
			width: 24px;
			height: 24px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.color-picker-btn {
			padding: 5px 10px;
			background-color: #f0f0f0;
			border: 1px solid #ccc;
			border-radius: 4px;
			cursor: pointer;
		}

		.color-picker-btn:hover {
			background-color: #e0e0e0;
		}

		.color-picker-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
		}

		.color-picker-content {
			background-color: white;
			padding: 20px;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			width: 300px;
		}

		.color-picker-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 15px;
		}

		.color-picker-header span {
			font-size: 16px;
			font-weight: bold;
		}

		.close-btn {
			background: none;
			border: none;
			font-size: 20px;
			cursor: pointer;
		}

		.color-picker-body {
			display: flex;
			gap: 10px;
			align-items: center;
			margin-bottom: 15px;
		}

		#color-picker-input {
			width: 100px;
			height: 40px;
		}

		#color-picker-preview {
			width: 40px;
			height: 40px;
			border: 1px solid #ccc;
			border-radius: 4px;
		}

		.color-picker-footer {
			text-align: right;
		}

		.confirm-btn {
			padding: 8px 16px;
			background-color: #4CAF50;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}

		.confirm-btn:hover {
			background-color: #45a049;
		}

		
        .shape-textarea::selection {
            background: rgba(61, 90, 254, 0.3);
            color: #000000;
        }

        /* 메뉴바 스타일 */
        .menu-bar {
            background-color: #ffffff;
            padding: 10px 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
        }
        .menu-bar a {
            margin-right: 20px;
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.2s;
        }
        .menu-bar a:hover {
            color: #3d5afe;
        }

        .top-bar {
            background-color: #3d5afe;
            color: white;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .app-title {
            font-size: 18px;
            font-weight: bold;
        }
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .toolbar {
            width: 80px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            box-shadow: 1px 0 3px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .fixed-tools {
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .accordion {
            flex: 1;
        }
        .accordion-item {
            border-bottom: 1px solid #e0e0e0;
        }
        .accordion-header {
            background-color: #f9f9f9;
            padding: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #5f6368;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .accordion-header:hover {
            background-color: #f0f0f0;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-content.active {
            max-height: 500px;
        }
        .tool-btn {
            min-width: 60px;
            height: 40px;
            margin: 5px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            font-size: 12px;
            padding: 8px;
        }
        .tool-btn:hover {
            background-color: #f0f0f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .tool-btn.active {
            background-color: #e3f2fd;
            border-color: #3d5afe;
        }
        .tool-icon {
            width: 24px;
            height: 24px;
            fill: #5f6368;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #f9f9f9;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #diagram-canvas {
            position: absolute;
            background-color: transparent;
            cursor: default;
        }
        .properties-panel {
            width: 250px;
            background-color: #fff;
            border-left: 1px solid #e0e0e0;
            padding: 15px;
            overflow-y: auto;
            box-shadow: -1px 0 3px rgba(0,0,0,0.1);
        }
        .properties-title {
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .property-group {
            margin-bottom: 15px;
        }
        .property-label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #5f6368;
        }
        .property-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 10px;
        }
        .color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 1px solid #e0e0e0;
        }
        .status-bar {
            height: 24px;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-size: 12px;
            color: #5f6368;
            border-top: 1px solid #e0e0e0;
        }
        .flex-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .property-row {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }
        .property-row label {
            flex: 1;
            font-size: 12px;
            color: #5f6368;
        }
        .property-row input, .property-row select {
            flex: 2;
            padding: 5px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        .hidden {
            display: none;
        }
        .context-menu {
            position: absolute;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }
        .flowchart-menu {
            position: absolute;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 200px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        .flowchart-item {
            padding: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid transparent;
        }
        .flowchart-item:hover {
            background-color: #f0f0f0;
            border-color: #3d5afe;
        }
        .flowchart-item svg {
            width: 24px;
            height: 24px;
        }
        .shape-textarea {
            position: absolute;
            border: none;
            background: rgba(255, 255, 255, 0.8);
            resize: none;
            font-size: 16px;
            padding: 5px;
            z-index: 10;
            box-shadow: 0 0 5px rgba(61, 90, 254, 0.3);
        }
    </style>
</head>
<body>
   <div class="menu-bar">
       <!-- <a href="#">홈</a>
        <a href="https://www.naver.com" target="_blank">네이버</a>
        <a href="https://www.kakao.com" target="_blank">카카오</a> -->
	   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4624141391435876"
	     crossorigin="anonymous"></script>
	<!-- [디스플레이, 반응형] 최상단 고정광고 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-4624141391435876"
	     data-ad-slot="8566506642"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
	     (adsbygoogle = window.adsbygoogle || []).push({});
	</script>
    </div>

    <div class="top-bar">
        <div class="app-title">웹 다이어그램 에디터</div>
        <div class="flex-row">
            <button id="save-image-btn" class="tool-btn">이미지 저장</button>
            <button id="save-btn" class="tool-btn">데이터 저장</button>
            <button id="load-btn" class="tool-btn">불러오기</button>
        </div>
    </div>
    
    <div class="main-container">
        <div class="toolbar">
            <div class="fixed-tools">
                <button id="front-tool" class="tool-btn" title="맨 앞으로">
                    <svg class="tool-icon" viewBox="0 0 24 24">
                        <path d="M3 3h18v2H3zm0 4h14v2H3zm0 4h10v2H3zm0 4h18v2H3z" />
                    </svg>
                </button>
                <button id="back-tool" class="tool-btn" title="맨 뒤로">
                    <svg class="tool-icon" viewBox="0 0 24 24">
                        <path d="M3 3h18v2H3zm0 4h10v2H3zm0 4h14v2H3zm0 4h18v2H3z" />
                    </svg>
                </button>
                <button id="select-tool" class="tool-btn active" title="선택">
                    <svg class="tool-icon" viewBox="0 0 24 24">
                        <path d="M17 5.92L9 2v18H7v-1.73c-1.79.35-3 .99-3 1.73 0 1.1 2.69 2 6 2s6-.9 6-2c0-.99-2.16-1.81-5-1.97V8.98l6-3.06z"/>
                    </svg>
                </button>
            </div>
            <div class="accordion">
                <div class="accordion-item">
                    <div class="accordion-header">일반</div>
                    <div class="accordion-content active">
                        <button id="rectangle-tool" class="tool-btn" title="사각형">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M19 3H5v16h14V3z"/>
                            </svg>
                        </button>
                        <button id="ellipse-tool" class="tool-btn" title="원">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>
                            </svg>
                        </button>
                        <button id="diamond-tool" class="tool-btn" title="다이아몬드">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M12 2L2 12l10 10 10-10z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header">순서도</div>
                    <div class="accordion-content">
                        <button id="parallelogram-tool" class="tool-btn" title="평행사변형">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M8 4h10l-4 12H4z"/>
                            </svg>
                        </button>
                        <button id="trapezoid-tool" class="tool-btn" title="사다리꼴">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M6 4h12l-4 12H10z"/>
                            </svg>
                        </button>
                        <button id="hexagon-tool" class="tool-btn" title="육각형">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M12 2l6 5v8l-6 5-6-5V7z"/>
                            </svg>
                        </button>
                        <button id="octagon-tool" class="tool-btn" title="팔각형">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M8 4l4-4 4 4v4l4 4-4 4h-4l-4-4z"/>
                            </svg>
                        </button>
                        <button id="triangle-tool" class="tool-btn" title="삼각형">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M12 2l10 20H2z"/>
                            </svg>
                        </button>
                        <button id="cylinder-tool" class="tool-btn" title="원통">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M6 4a6 2 0 0112 0v16a6 2 0 01-12 0z"/>
                            </svg>
                        </button>
                        <button id="text-tool" class="tool-btn" title="텍스트">
                            <svg class="tool-icon" viewBox="0 0 24 24">
                                <path d="M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="diagram-canvas"></canvas>
        </div>
        
        <div class="properties-panel">
            <div class="properties-title">속성</div>
            <div id="creation-mode" class="property-group">
                <div class="property-row">
                    <label>생성 모드</label>
                    <div>
                        <input type="radio" id="continuous-creation" name="creation-mode" value="continuous">
                        <label for="continuous-creation">연속 생성</label>
                        <input type="radio" id="single-creation" name="creation-mode" value="single" checked>
                        <label for="single-creation">단일 생성 후 선택</label>
                    </div>
                </div>
            </div>
            <div id="shape-properties" class="property-group">
                <div class="property-row">
                    <label>채우기 색상</label>
                    <div class="color-picker-wrapper">
                        <div class="color-preview" id="fill-color-preview" style="background-color: #ffffff;"></div>
                        <button class="color-picker-btn" data-target="fill-color">색상 선택</button>
                    </div>
                </div>
                <div class="property-row">
                    <label>테두리 색상</label>
                    <div class="color-picker-wrapper">
                        <div class="color-preview" id="stroke-color-preview" style="background-color: #000000;"></div>
                        <button class="color-picker-btn" data-target="stroke-color">색상 선택</button>
                    </div>
                </div>
                <div class="property-row">
                    <label>테두리 두께</label>
                    <input type="number" id="stroke-width" class="property-input" value="2" min="1" max="10">
                </div>
                <div class="property-row">
                    <label>선 스타일</label>
                    <select id="stroke-style" class="property-input">
                        <option value="solid">실선</option>
                        <option value="dashed">점선</option>
                        <option value="double">두 줄선</option>
                    </select>
                </div>
            </div>

            <div id="text-properties" class="property-group hidden">
                <div class="property-row">
                    <label>텍스트</label>
                    <textarea id="text-content" class="property-input" rows="3">텍스트</textarea>
                </div>
                <div class="property-row">
                    <label>글자 크기</label>
                    <input type="number" id="font-size" class="property-input" value="16" min="8" max="72">
                </div>
                <div class="property-row">
                    <label>글자 색상</label>
                    <div class="color-picker-wrapper">
                        <div class="color-preview" id="text-color-preview" style="background-color: #000000;"></div>
                        <button class="color-picker-btn" data-target="text-color">색상 선택</button>
                    </div>
                </div>
                <div class="property-row">
                    <label>폰트 스타일</label>
                    <div class="flex-row">
                        <input type="checkbox" id="font-bold" name="font-style">
                        <label for="font-bold">굵게</label>
                        <input type="checkbox" id="font-italic" name="font-style">
                        <label for="font-italic">기울임</label>
                        <input type="checkbox" id="font-underline" name="font-style">
                        <label for="font-underline">밑줄</label>
                    </div>
                </div>
            </div>

            <!-- 커스텀 색상 선택 창 -->
            <div id="color-picker-modal" class="color-picker-modal hidden">
                <div class="color-picker-content">
                    <div class="color-picker-header">
                        <span>색상 선택</span>
                        <button class="close-btn">×</button>
                    </div>
                    <div class="color-picker-body">
                        <input type="color" id="color-picker-input">
                        <div class="color-preview" id="color-picker-preview"></div>
                    </div>
                    <div class="color-picker-footer">
                        <button class="confirm-btn">확인</button>
                    </div>
                </div>
            </div>
            <div id="position-properties" class="property-group">
                <div class="property-row">
                    <label>X</label>
                    <input type="number" id="pos-x" class="property-input" value="0">
                </div>
                <div class="property-row">
                    <label>Y</label>
                    <input type="number" id="pos-y" class="property-input" value="0">
                </div>
                <div class="property-row">
                    <label>Width</label>
                    <input type="number" id="pos-width" class="property-input" value="100">
                </div>
                <div class="property-row">
                    <label>Height</label>
                    <input type="number" id="pos-height" class="property-input" value="80">
                </div>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <span id="coordinates">X: 0, Y: 0</span>
    </div>
    
    <script>
	document.addEventListener('DOMContentLoaded', function() {
			const canvas = document.getElementById('diagram-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.querySelector('.canvas-container');
            let currentTool = 'select';
            let isDrawing = false;
            let startX, startY;
            let elements = [];
            let selectedElements = [];
            let tempElement = null;
            let dragOffsetX = 0, dragOffsetY = 0;
            let resizing = false;
            let resizeHandle = null;
            let selectionRect = null;
            let contextMenu = null;
            let flowchartMenu = null;
            let selectedLineType = null;
            let connectingShape = null;
            let creationMode = 'single';
            let copiedElements = [];
            let scale = 1;
            let offsetX = 0, offsetY = 0;
            let isPanning = false;
            let panStartX, panStartY;
            let movingLineEndpoint = null;
            let mouseX = 0, mouseY = 0;

            let currentColorTarget = null; // 현재 색상 변경 대상 ('fill-color', 'stroke-color', 'text-color')

    
	
	// 현재 색상 변경 대상 ('fill-color', 'stroke-color', 'text-color')
	function showColorPicker(target) {
		currentColorTarget = target;
		const modal = document.getElementById('color-picker-modal');
		const colorInput = document.getElementById('color-picker-input');
		const colorPreview = document.getElementById('color-picker-preview');

		// 현재 색상으로 초기화
		const currentColor = document.getElementById(`${target}-preview`).style.backgroundColor;
		const hexColor = rgbToHex(currentColor) || '#000000';
		colorInput.value = hexColor;
		colorPreview.style.backgroundColor = hexColor;

		modal.classList.remove('hidden');

		// 색상 입력 시 미리보기 업데이트
		const updatePreview = () => {
			colorPreview.style.backgroundColor = colorInput.value;
		};
		colorInput.removeEventListener('input', updatePreview); // 기존 리스너 제거
		colorInput.addEventListener('input', updatePreview); // 새 리스너 추가
	}
	
	// RGB 문자열을 HEX로 변환하는 헬퍼 함수
	function rgbToHex(rgb) {
		if (!rgb || rgb === '') return null;
		const rgbMatch = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
		if (!rgbMatch) return null;
		const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
		const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
		const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
		return `#${r}${g}${b}`;
	}
	
	function applyColor() {
		if (!currentColorTarget) return;
		const colorInput = document.getElementById('color-picker-input');
		const newColor = colorInput.value;

		// 색상 미리보기 업데이트
		document.getElementById(`${currentColorTarget}-preview`).style.backgroundColor = newColor;

		// 선택된 요소에 색상 적용
		if (selectedElements.length > 0) {
			selectedElements.forEach(element => {
				if (currentColorTarget === 'fill-color' && element.type !== 'line') {
					element.fillColor = newColor;
				} else if (currentColorTarget === 'stroke-color') {
					element.strokeColor = newColor;
				} else if (currentColorTarget === 'text-color' && element.type !== 'line') {
					if (element.textFragments && element.textFragments.length > 0) {
						element.textFragments.forEach(fragment => {
							fragment.style.color = newColor;
						});
					}
					element.defaultTextColor = newColor;
				}
			});
			drawDiagram();
		}

		closeColorPicker();
	}
	
	function closeColorPicker() {
		const modal = document.getElementById('color-picker-modal');
		modal.classList.add('hidden');
		currentColorTarget = null;
	}
		
	
	// 색상 선택 버튼에 이벤트 리스너 추가
	document.querySelectorAll('.color-picker-btn').forEach(button => {
		button.addEventListener('click', () => {
			const target = button.getAttribute('data-target');
			showColorPicker(target);
		});
	});
	
	// 색상 선택 모달의 확인 및 닫기 버튼에 이벤트 리스너 추가
	const colorPickerModal = document.getElementById('color-picker-modal');
	const confirmBtn = colorPickerModal.querySelector('.confirm-btn');
	const closeBtn = colorPickerModal.querySelector('.close-btn');
	
	confirmBtn.addEventListener('click', applyColor);
	closeBtn.addEventListener('click', closeColorPicker);
	
	// 아코디언 기능 추가
	document.querySelectorAll('.accordion-header').forEach(header => {
		header.addEventListener('click', function() {
			const content = this.nextElementSibling;
			content.classList.toggle('active');
		});
	});

    function isValidGroup(selectedElements) {
		if (selectedElements.length < 3) return false; // 최소 2개의 도형과 1개의 선이 필요

		const shapes = selectedElements.filter(el => el.type !== 'line' && el.type !== 'text');
		const lines = selectedElements.filter(el => el.type === 'line');

		// 도형이 2개 이상이고, 선의 개수가 도형 개수 - 1이어야 함 (직렬 연결)
		if (shapes.length < 2 || lines.length !== shapes.length - 1) return false;

		// 도형과 선을 연결 순서대로 정렬
		let orderedShapes = [];
		let orderedLines = [];
		let currentShape = shapes[0];
		orderedShapes.push(currentShape);

		while (orderedLines.length < lines.length) {
			let found = false;
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				if (orderedLines.includes(line)) continue;

				if (line.startShape === currentShape) {
					orderedLines.push(line);
					currentShape = line.endShape;
					orderedShapes.push(currentShape);
					found = true;
					break;
				} else if (line.endShape === currentShape) {
					orderedLines.push(line);
					currentShape = line.startShape;
					orderedShapes.push(currentShape);
					found = true;
					break;
				}
			}
			if (!found) return false; // 연결이 끊겼으면 유효하지 않은 그룹
		}

		// 모든 도형이 선택된 도형 목록에 포함되어야 함
		return orderedShapes.every(shape => shapes.includes(shape));
	}

    function insertGroupIntoLine(group, intersectedLine) {
		const shapes = group.filter(el => el.type !== 'line' && el.type !== 'text');
		const lines = group.filter(el => el.type === 'line');

		if (shapes.length < 2 || lines.length !== shapes.length - 1) return;

		// 도형과 선을 연결 순서대로 정렬
		let orderedShapes = [];
		let orderedLines = [];
		let currentShape = shapes[0];
		orderedShapes.push(currentShape);

		let remainingLines = [...lines];
		while (orderedLines.length < lines.length) {
			let found = false;
			for (let i = 0; i < remainingLines.length; i++) {
				const line = remainingLines[i];
				if (line.startShape === currentShape) {
					orderedLines.push(line);
					currentShape = line.endShape;
					orderedShapes.push(currentShape);
					remainingLines.splice(i, 1);
					found = true;
					break;
				} else if (line.endShape === currentShape) {
					orderedLines.push(line);
					currentShape = line.startShape;
					orderedShapes.push(currentShape);
					remainingLines.splice(i, 1);
					found = true;
					break;
				}
			}
			if (!found) return; // 연결이 끊겼으면 삽입 중단
		}

		// 삽입할 선의 시작점과 끝점
		const startShape = intersectedLine.startShape;
		const endShape = intersectedLine.endShape;
		const lineType = intersectedLine.lineType;
		const strokeColor = intersectedLine.strokeColor;
		const strokeWidth = intersectedLine.strokeWidth;

		// 그룹의 첫 번째 도형과 마지막 도형
		const groupStartShape = orderedShapes[0];
		const groupEndShape = orderedShapes[orderedShapes.length - 1];

		// 새로운 선 생성: 시작점 → 그룹 첫 도형, 그룹 마지막 도형 → 끝점
		const newLine1 = {
			id: Date.now() + Math.random(),
			type: 'line',
			startShape: startShape,
			endShape: groupStartShape,
			startShapeId: startShape.id,
			endShapeId: groupStartShape.id,
			lineType: lineType,
			strokeColor: strokeColor,
			strokeWidth: strokeWidth
		};
		const newLine2 = {
			id: Date.now() + Math.random(),
			type: 'line',
			startShape: groupEndShape,
			endShape: endShape,
			startShapeId: groupEndShape.id,
			endShapeId: endShape.id,
			lineType: lineType,
			strokeColor: strokeColor,
			strokeWidth: strokeWidth
		};

		// 기존 선 제거
		const index = elements.indexOf(intersectedLine);
		if (index !== -1) elements.splice(index, 1);

		// 새로운 선 추가
		elements.push(newLine1, newLine2);

		// 임시 색상 제거
		group.forEach(element => {
			if (element.type !== 'line') {
				delete element.tempFillColor;
			}
		});
	}

    function resizeCanvas() {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
        drawDiagram();
    }

    function getClosestEdge(startShape, endShape) {
        if (!startShape || !endShape) return { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
        const startEdges = [
            { angle: 0, x: startShape.x + startShape.width, y: startShape.y + startShape.height / 2 },
            { angle: 90, x: startShape.x + startShape.width / 2, y: startShape.y },
            { angle: 180, x: startShape.x, y: startShape.y + startShape.height / 2 },
            { angle: 270, x: startShape.x + startShape.width / 2, y: startShape.y + startShape.height }
        ];
        const endEdges = [
            { angle: 0, x: endShape.x + endShape.width, y: endShape.y + endShape.height / 2 },
            { angle: 90, x: endShape.x + endShape.width / 2, y: endShape.y },
            { angle: 180, x: endShape.x, y: endShape.y + endShape.height / 2 },
            { angle: 270, x: endShape.x + endShape.width / 2, y: endShape.y + endShape.height }
        ];
        let minDist = Infinity;
        let closestStart = startEdges[0];
        let closestEnd = endEdges[0];
        startEdges.forEach(start => {
            endEdges.forEach(end => {
                const dist = Math.hypot(start.x - end.x, start.y - end.y);
                if (dist < minDist) {
                    minDist = dist;
                    closestStart = start;
                    closestEnd = end;
                }
            });
        });
        return { start: closestStart, end: closestEnd };
    }

    function drawElement(element) {
		ctx.save();
		ctx.translate(offsetX, offsetY);
		ctx.scale(scale, scale);
		const fillColor = element.tempFillColor || element.fillColor || '#ffffff';
		const strokeColor = element.strokeColor || '#000000';
		const strokeWidth = element.strokeWidth || 2;
		const strokeStyle = element.strokeStyle || 'solid'; // 기본값: 실선
		ctx.fillStyle = fillColor;
		ctx.strokeStyle = strokeColor;
		ctx.lineWidth = strokeWidth;

		// 선 스타일 적용
		if (strokeStyle === 'dashed') {
			ctx.setLineDash([5, 5]); // 점선
		} else {
			ctx.setLineDash([]); // 실선 또는 두 줄선
		}

		switch (element.type) {
			case 'rectangle':
				ctx.beginPath();
				ctx.rect(element.x, element.y, element.width, element.height);
				ctx.fill();
				if (strokeStyle === 'double') {
					// 바깥 선
					ctx.stroke();
					// 안쪽 선
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.rect(
						element.x + inset,
						element.y + inset,
						element.width - 2 * inset,
						element.height - 2 * inset
					);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'ellipse':
				ctx.beginPath();
				ctx.ellipse(
					element.x + element.width / 2,
					element.y + element.height / 2,
					Math.abs(element.width / 2),
					Math.abs(element.height / 2),
					0,
					0,
					Math.PI * 2
				);
				ctx.fill();
				if (strokeStyle === 'double') {
					// 바깥 선
					ctx.stroke();
					// 안쪽 선
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.ellipse(
						element.x + element.width / 2,
						element.y + element.height / 2,
						Math.abs(element.width / 2) - inset,
						Math.abs(element.height / 2) - inset,
						0,
						0,
						Math.PI * 2
					);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'diamond':
				const diamondPath = () => {
					ctx.moveTo(element.x + element.width / 2, element.y);
					ctx.lineTo(element.x + element.width, element.y + element.height / 2);
					ctx.lineTo(element.x + element.width / 2, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height / 2);
					ctx.closePath();
				};
				ctx.beginPath();
				diamondPath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width / 2, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height / 2);
					ctx.lineTo(element.x + element.width / 2, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height / 2);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'parallelogram':
				const parallelogramPath = () => {
					ctx.moveTo(element.x + element.width * 0.2, element.y);
					ctx.lineTo(element.x + element.width, element.y);
					ctx.lineTo(element.x + element.width * 0.8, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height);
					ctx.closePath();
				};
				ctx.beginPath();
				parallelogramPath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width * 0.2 + inset, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + inset);
					ctx.lineTo(element.x + element.width * 0.8 - inset, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height - inset);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'trapezoid':
				const trapezoidPath = () => {
					ctx.moveTo(element.x + element.width * 0.2, element.y);
					ctx.lineTo(element.x + element.width * 0.8, element.y);
					ctx.lineTo(element.x + element.width, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height);
					ctx.closePath();
				};
				ctx.beginPath();
				trapezoidPath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width * 0.2 + inset, element.y + inset);
					ctx.lineTo(element.x + element.width * 0.8 - inset, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height - inset);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'hexagon':
				const hexagonPath = () => {
					ctx.moveTo(element.x + element.width * 0.25, element.y);
					ctx.lineTo(element.x + element.width * 0.75, element.y);
					ctx.lineTo(element.x + element.width, element.y + element.height / 2);
					ctx.lineTo(element.x + element.width * 0.75, element.y + element.height);
					ctx.lineTo(element.x + element.width * 0.25, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height / 2);
					ctx.closePath();
				};
				ctx.beginPath();
				hexagonPath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width * 0.25 + inset, element.y + inset);
					ctx.lineTo(element.x + element.width * 0.75 - inset, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height / 2);
					ctx.lineTo(element.x + element.width * 0.75 - inset, element.y + element.height - inset);
					ctx.lineTo(element.x + element.width * 0.25 + inset, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height / 2);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'octagon':
				const octagonPath = () => {
					ctx.moveTo(element.x + element.width * 0.3, element.y);
					ctx.lineTo(element.x + element.width * 0.7, element.y);
					ctx.lineTo(element.x + element.width, element.y + element.height * 0.3);
					ctx.lineTo(element.x + element.width, element.y + element.height * 0.7);
					ctx.lineTo(element.x + element.width * 0.7, element.y + element.height);
					ctx.lineTo(element.x + element.width * 0.3, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height * 0.7);
					ctx.lineTo(element.x, element.y + element.height * 0.3);
					ctx.closePath();
				};
				ctx.beginPath();
				octagonPath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width * 0.3 + inset, element.y + inset);
					ctx.lineTo(element.x + element.width * 0.7 - inset, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height * 0.3 + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height * 0.7 - inset);
					ctx.lineTo(element.x + element.width * 0.7 - inset, element.y + element.height - inset);
					ctx.lineTo(element.x + element.width * 0.3 + inset, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height * 0.7 - inset);
					ctx.lineTo(element.x + inset, element.y + element.height * 0.3 + inset);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'triangle':
				const trianglePath = () => {
					ctx.moveTo(element.x + element.width / 2, element.y);
					ctx.lineTo(element.x + element.width, element.y + element.height);
					ctx.lineTo(element.x, element.y + element.height);
					ctx.closePath();
				};
				ctx.beginPath();
				trianglePath();
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + element.width / 2, element.y + inset);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height - inset);
					ctx.lineTo(element.x + inset, element.y + element.height - inset);
					ctx.closePath();
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'cylinder':
				ctx.beginPath();
				ctx.ellipse(
					element.x + element.width / 2,
					element.y,
					Math.abs(element.width / 2),
					Math.abs(element.height / 6),
					0,
					0,
					Math.PI * 2
				);
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.ellipse(
						element.x + element.width / 2,
						element.y,
						Math.abs(element.width / 2) - inset,
						Math.abs(element.height / 6) - inset,
						0,
						0,
						Math.PI * 2
					);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				ctx.beginPath();
				ctx.ellipse(
					element.x + element.width / 2,
					element.y + element.height,
					Math.abs(element.width / 2),
					Math.abs(element.height / 6),
					0,
					0,
					Math.PI * 2
				);
				ctx.fill();
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.ellipse(
						element.x + element.width / 2,
						element.y + element.height,
						Math.abs(element.width / 2) - inset,
						Math.abs(element.height / 6) - inset,
						0,
						0,
						Math.PI * 2
					);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				ctx.beginPath();
				ctx.moveTo(element.x, element.y + element.height / 6);
				ctx.lineTo(element.x, element.y + element.height - element.height / 6);
				ctx.moveTo(element.x + element.width, element.y + element.height / 6);
				ctx.lineTo(element.x + element.width, element.y + element.height - element.height / 6);
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.moveTo(element.x + inset, element.y + element.height / 6);
					ctx.lineTo(element.x + inset, element.y + element.height - element.height / 6);
					ctx.moveTo(element.x + element.width - inset, element.y + element.height / 6);
					ctx.lineTo(element.x + element.width - inset, element.y + element.height - element.height / 6);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				ctx.beginPath();
				ctx.ellipse(
					element.x + element.width / 2,
					element.y + element.height,
					Math.abs(element.width / 2),
					Math.abs(element.height / 6),
					0,
					Math.PI,
					2 * Math.PI
				);
				if (strokeStyle === 'double') {
					ctx.stroke();
					const inset = strokeWidth * 2;
					ctx.beginPath();
					ctx.ellipse(
						element.x + element.width / 2,
						element.y + element.height,
						Math.abs(element.width / 2) - inset,
						Math.abs(element.height / 6) - inset,
						0,
						Math.PI,
						2 * Math.PI
					);
					ctx.stroke();
				} else {
					ctx.stroke();
				}
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;

			case 'line':
				if (element.startShape && element.endShape) {
					const edges = getClosestEdge(element.startShape, element.endShape);
					const start = edges.start;
					const end = edges.end;

					ctx.beginPath();
					ctx.moveTo(start.x, start.y);
					if (element.lineType === 'bent') {
						const midX = (start.x + end.x) / 2;
						ctx.lineTo(midX, start.y);
						ctx.lineTo(midX, end.y);
						ctx.lineTo(end.x, end.y);
					} else {
						ctx.lineTo(end.x, end.y);
					}

					if (strokeStyle === 'double') {
						// 첫 번째 선
						ctx.stroke();
						// 두 번째 선 (평행선)
						const angle = Math.atan2(end.y - start.y, end.x - start.x);
						const offset = strokeWidth * 2;
						const dx = offset * Math.sin(angle);
						const dy = offset * Math.cos(angle);
						ctx.beginPath();
						if (element.lineType === 'bent') {
							const midX = (start.x + end.x) / 2;
							ctx.moveTo(start.x + dx, start.y - dy);
							ctx.lineTo(midX + dx, start.y - dy);
							ctx.lineTo(midX + dx, end.y - dy);
							ctx.lineTo(end.x + dx, end.y - dy);
						} else {
							ctx.moveTo(start.x + dx, start.y - dy);
							ctx.lineTo(end.x + dx, end.y - dy);
						}
						ctx.stroke();
					} else {
						ctx.stroke();
					}

					if (element.lineType === 'arrow' || element.lineType === 'double-arrow') {
						const angle = Math.atan2(end.y - start.y, end.x - start.x);
						const arrowSize = 10;
						ctx.beginPath();
						ctx.moveTo(end.x, end.y);
						ctx.lineTo(
							end.x - arrowSize * Math.cos(angle - Math.PI / 6),
							end.y - arrowSize * Math.sin(angle - Math.PI / 6)
						);
						ctx.moveTo(end.x, end.y);
						ctx.lineTo(
							end.x - arrowSize * Math.cos(angle + Math.PI / 6),
							end.y - arrowSize * Math.sin(angle + Math.PI / 6)
						);
						if (strokeStyle === 'double') {
							const offset = strokeWidth * 2;
							const dx = offset * Math.sin(angle);
							const dy = offset * Math.cos(angle);
							ctx.moveTo(end.x + dx, end.y - dy);
							ctx.lineTo(
								end.x + dx - arrowSize * Math.cos(angle - Math.PI / 6),
								end.y - dy - arrowSize * Math.sin(angle - Math.PI / 6)
							);
							ctx.moveTo(end.x + dx, end.y - dy);
							ctx.lineTo(
								end.x + dx - arrowSize * Math.cos(angle + Math.PI / 6),
								end.y - dy - arrowSize * Math.sin(angle + Math.PI / 6)
							);
						}
						ctx.stroke();
					}

					if (element.lineType === 'double-arrow') {
						const angle = Math.atan2(start.y - end.y, start.x - end.x);
						const arrowSize = 10;
						ctx.beginPath();
						ctx.moveTo(start.x, start.y);
						ctx.lineTo(
							start.x - arrowSize * Math.cos(angle - Math.PI / 6),
							start.y - arrowSize * Math.sin(angle - Math.PI / 6)
						);
						ctx.moveTo(start.x, start.y);
						ctx.lineTo(
							start.x - arrowSize * Math.cos(angle + Math.PI / 6),
							start.y - arrowSize * Math.sin(angle + Math.PI / 6)
						);
						if (strokeStyle === 'double') {
							const offset = strokeWidth * 2;
							const dx = offset * Math.sin(angle);
							const dy = offset * Math.cos(angle);
							ctx.moveTo(start.x + dx, start.y - dy);
							ctx.lineTo(
								start.x + dx - arrowSize * Math.cos(angle - Math.PI / 6),
								start.y - dy - arrowSize * Math.sin(angle - Math.PI / 6)
							);
							ctx.moveTo(start.x + dx, start.y - dy);
							ctx.lineTo(
								start.x + dx - arrowSize * Math.cos(angle + Math.PI / 6),
								start.y - dy - arrowSize * Math.sin(angle + Math.PI / 6)
							);
						}
						ctx.stroke();
					}
				}
				break;

			case 'text':
				if (element.textFragments && element.textFragments.length > 0) {
					drawMultiLineText(
						element.textFragments,
						element.x + element.width / 2,
						element.y + element.height / 2
					);
				}
				break;
		}

		ctx.setLineDash([]); // 다음 요소를 위해 초기화
		ctx.restore();
	}

    function drawMultiLineText(textFragments, x, y) {
		ctx.textAlign = 'center';
		const lineHeight = (textFragments[0]?.style?.fontSize || 16) * 1.2;
		let totalHeight = 0;
		const lines = [];

		textFragments.forEach(fragment => {
			const fragmentLines = fragment.content.split('\n');
			fragmentLines.forEach((line, index) => {
				lines.push({
					content: line,
					style: fragment.style || {
						color: '#000000',
						fontSize: 16,
						bold: false,
						italic: false,
						underline: false
					}
				});
				if (index < fragmentLines.length - 1) {
					totalHeight += lineHeight;
				}
			});
		});

		totalHeight = lines.length * lineHeight;
		const startY = y - totalHeight / 2 + lineHeight / 2;

		lines.forEach((line, index) => {
			const style = line.style;
			ctx.font = `${style.italic ? 'italic ' : ''}${style.bold ? 'bold ' : ''}${style.fontSize}px Arial`;
			ctx.fillStyle = style.color;

			const lineY = startY + index * lineHeight;
			ctx.fillText(line.content, x, lineY);

			if (style.underline) {
				const textWidth = ctx.measureText(line.content).width;
				ctx.beginPath();
				ctx.moveTo(x - textWidth / 2, lineY + 2);
				ctx.lineTo(x + textWidth / 2, lineY + 2);
				ctx.strokeStyle = style.color;
				ctx.lineWidth = 1;
				ctx.stroke();
			}
		});
	}

    function drawArrowHead(fromX, fromY, toX, toY) {
        const headLength = 10 / scale;
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
    }

    function drawHandle(x, y) {
        ctx.fillStyle = '#3d5afe';
        const handleSize = 6 / scale;
        ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        ctx.strokeStyle = '#ffffff';
        ctx.strokeRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
    }

    function drawSelectionHandles() {
        if (selectedElements.length === 0) return;
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        if (selectedElements.length === 1) {
            const element = selectedElements[0];
            ctx.strokeStyle = '#3d5afe';
            ctx.lineWidth = 1 / scale;
            ctx.setLineDash([5 / scale, 3 / scale]);
            if (element.type === 'line' && element.startShape && element.endShape) {
                const edges = getClosestEdge(element.startShape, element.endShape);
                ctx.beginPath();
                ctx.moveTo(edges.start.x, edges.start.y);
                ctx.lineTo(edges.end.x, edges.end.y);
                ctx.stroke();
                drawHandle(edges.start.x, edges.start.y);
                drawHandle(edges.end.x, edges.end.y);
            } else if (element.type !== 'line') {
                ctx.beginPath();
                ctx.rect(element.x - 2 / scale, element.y - 2 / scale, element.width + 4 / scale, element.height + 4 / scale);
                ctx.stroke();
                drawHandle(element.x, element.y);
                drawHandle(element.x + element.width, element.y);
                drawHandle(element.x, element.y + element.height);
                drawHandle(element.x + element.width, element.y + element.height);
            }
        } else {
            const bounds = getSelectionBounds();
            ctx.strokeStyle = '#3d5afe';
            ctx.lineWidth = 1 / scale;
            ctx.setLineDash([5 / scale, 3 / scale]);
            ctx.beginPath();
            ctx.rect(bounds.x - 2 / scale, bounds.y - 2 / scale, bounds.width + 4 / scale, bounds.height + 4 / scale);
            ctx.stroke();
            drawHandle(bounds.x, bounds.y);
            drawHandle(bounds.x + bounds.width, bounds.y);
            drawHandle(bounds.x, bounds.y + bounds.height);
            drawHandle(bounds.x + bounds.width, bounds.y + bounds.height);
        }
        ctx.setLineDash([]);
        ctx.restore();
    }

    function drawDiagram() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        elements.forEach(element => drawElement(element));
        if (tempElement) drawElement(tempElement);
        if (selectionRect) {
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.strokeStyle = '#3d5afe';
            ctx.lineWidth = 1 / scale;
            ctx.setLineDash([5 / scale, 3 / scale]);
            ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
            ctx.restore();
            ctx.setLineDash([]);
        }
        drawSelectionHandles();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            const toolId = this.id;
            if (toolId === 'save-btn') {
                saveDiagram();
                return;
            }
            if (toolId === 'save-image-btn') {
                saveCanvasAsImage();
                return;
            }
            if (toolId === 'load-btn') {
                loadDiagram();
                return;
            }
            if (toolId === 'front-tool') {
                bringToFront();
                return;
            }
            if (toolId === 'back-tool') {
                sendToBack();
                return;
            }
            document.querySelectorAll('.toolbar .tool-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentTool = toolId.replace('-tool', '');
            selectedElements = [];
            updatePropertiesPanel();
            drawDiagram();
        });
    });

    document.querySelectorAll('.property-input').forEach(input => {
        input.addEventListener('change', updateSelectedElement);
    });

    document.querySelectorAll('input[name="creation-mode"]').forEach(radio => {
        radio.addEventListener('change', function() {
            creationMode = this.value;
        });
    });

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('contextmenu', handleContextMenu);
    canvas.addEventListener('wheel', handleWheel);
    canvas.addEventListener('dblclick', handleDoubleClick);

    document.addEventListener('click', (e) => {
        if (contextMenu && !contextMenu.contains(e.target)) {
            contextMenu.remove();
            contextMenu = null;
        }
        if (flowchartMenu && !flowchartMenu.contains(e.target)) {
            flowchartMenu.remove();
            flowchartMenu = null;
        }
    });

    function saveCanvasAsImage() {
        html2canvas(canvas).then(canvas => {
            const link = document.createElement('a');
            link.download = `diagram-${new Date().toISOString().slice(0,10)}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    }

	function handleDoubleClick(e) {
		const rect = canvas.getBoundingClientRect();
		const x = (e.clientX - rect.left - offsetX) / scale;
		const y = (e.clientY - rect.top - offsetY) / scale;
		const element = getElementAt(x, y);

		if (element && element.type !== 'line' && element.type !== 'text') {
			const textarea = document.createElement('textarea');
			textarea.className = 'shape-textarea';
			const padding = 5;
			textarea.style.left = `${rect.left + (element.x + padding) * scale + offsetX}px`;
			textarea.style.top = `${rect.top + (element.y + padding) * scale + offsetY}px`;
			textarea.style.width = `${(element.width - 2 * padding) * scale}px`;
			textarea.style.height = `${(element.height - 2 * padding) * scale}px`;
			textarea.style.fontSize = `${(element.defaultFontSize || 16) * scale}px`;
			const initialText = element.textFragments
				? element.textFragments.map(fragment => fragment.content).join('\n')
				: '';
			textarea.value = initialText;
			document.body.appendChild(textarea);
			textarea.focus();

			selectedElements = [element];
			updatePropertiesPanel();

			let selectionStart = 0;
			let selectionEnd = 0;

			textarea.addEventListener('select', () => {
				selectionStart = textarea.selectionStart;
				selectionEnd = textarea.selectionEnd;
			});

			textarea.addEventListener('keydown', (e) => {
				if (e.key === 'Delete' || e.key === 'Backspace') {
					e.stopPropagation();
				}
			});

			textarea.addEventListener('blur', () => {
				const newText = textarea.value;
				if (!newText) {
					element.textFragments = [];
				} else {
					const lines = newText.split('\n');
					element.textFragments = lines.map((line, index) => {
						const existingFragment = element.textFragments[index] || {};
						return {
							content: line,
							style: {
								color: existingFragment.style?.color || element.defaultTextColor || '#000000',
								fontSize: existingFragment.style?.fontSize || element.defaultFontSize || 16,
								bold: existingFragment.style?.bold || false,
								italic: existingFragment.style?.italic || false,
								underline: existingFragment.style?.underline || false
							}
						};
					});
				}
				document.body.removeChild(textarea);
				updatePropertiesPanel();
				drawDiagram();
			});

			const moveHandler = () => {
				textarea.style.left = `${rect.left + (element.x + padding) * scale + offsetX}px`;
				textarea.style.top = `${rect.top + (element.y + padding) * scale + offsetY}px`;
			};
			canvas.addEventListener('mousemove', moveHandler);
			textarea.addEventListener('blur', () => {
				canvas.removeEventListener('mousemove', moveHandler);
			});

			const applyStyleToSelection = () => {
				if (!element.textFragments || element.textFragments.length === 0) return;

				const fullText = textarea.value;
				const newFragments = [];

				if (selectionStart === selectionEnd) {
					// 선택된 텍스트가 없으면 모든 조각에 스타일만 업데이트
					element.textFragments.forEach(fragment => {
						newFragments.push({
							content: fragment.content,
							style: {
								color: document.getElementById('text-color-preview').style.backgroundColor,
								fontSize: parseInt(document.getElementById('font-size').value),
								bold: document.getElementById('font-bold').checked,
								italic: document.getElementById('font-italic').checked,
								underline: document.getElementById('font-underline').checked
							}
						});
					});
				} else {
					// 선택된 텍스트가 있으면 해당 부분만 스타일 적용
					let currentPos = 0;
					element.textFragments.forEach(fragment => {
						const fragmentStart = currentPos;
						const fragmentEnd = currentPos + fragment.content.length;
						currentPos += fragment.content.length + (fragmentEnd < fullText.length && fullText[fragmentEnd] === '\n' ? 1 : 0);

						if (fragmentEnd <= selectionStart || fragmentStart >= selectionEnd) {
							newFragments.push({ ...fragment });
						} else {
							const text = fragment.content;
							const relativeStart = Math.max(0, selectionStart - fragmentStart);
							const relativeEnd = Math.min(text.length, selectionEnd - fragmentStart);

							if (relativeStart > 0) {
								newFragments.push({
									content: text.substring(0, relativeStart),
									style: { ...fragment.style }
								});
							}

							if (relativeEnd > relativeStart) {
								newFragments.push({
									content: text.substring(relativeStart, relativeEnd),
									style: {
										color: document.getElementById('text-color-preview').style.backgroundColor,
										fontSize: parseInt(document.getElementById('font-size').value),
										bold: document.getElementById('font-bold').checked,
										italic: document.getElementById('font-italic').checked,
										underline: document.getElementById('font-underline').checked
									}
								});
							}

							if (relativeEnd < text.length) {
								newFragments.push({
									content: text.substring(relativeEnd),
									style: { ...fragment.style }
								});
							}
						}
					});
				}

				element.textFragments = newFragments.filter(fragment => fragment.content);
				updatePropertiesPanel();
				drawDiagram();
			};

			const textColorPreview = document.getElementById('text-color-preview');
			const fontSizeInput = document.getElementById('font-size');
			const fontBoldInput = document.getElementById('font-bold');
			const fontItalicInput = document.getElementById('font-italic');
			const fontUnderlineInput = document.getElementById('font-underline');

			// 색상 변경 이벤트는 applyColor 함수에서 처리하므로 제거
			fontSizeInput.addEventListener('change', applyStyleToSelection);
			fontBoldInput.addEventListener('change', applyStyleToSelection);
			fontItalicInput.addEventListener('change', applyStyleToSelection);
			fontUnderlineInput.addEventListener('change', applyStyleToSelection);

			textarea.addEventListener('blur', () => {
				fontSizeInput.removeEventListener('change', applyStyleToSelection);
				fontBoldInput.removeEventListener('change', applyStyleToSelection);
				fontItalicInput.removeEventListener('change', applyStyleToSelection);
				fontUnderlineInput.removeEventListener('change', applyStyleToSelection);
			});
		}
	}

    function handleContextMenu(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;
        const element = getElementAt(x, y);

        if (contextMenu) contextMenu.remove();
        contextMenu = document.createElement('div');
        contextMenu.className = 'context-menu';
        contextMenu.style.left = `${e.clientX}px`;
        contextMenu.style.top = `${e.clientY}px`;

        if (element && element.type !== 'line') {
            const options = [
                { label: '직선 연결', value: 'straight', action: () => { selectedLineType = 'straight'; connectingShape = element; } },
                { label: '꺾인 선 연결', value: 'bent', action: () => { selectedLineType = 'bent'; connectingShape = element; } },
                { label: '화살표 연결', value: 'arrow', action: () => { selectedLineType = 'arrow'; connectingShape = element; } },
                { label: '양끝 화살표 연결', value: 'double-arrow', action: () => { selectedLineType = 'double-arrow'; connectingShape = element; } },
                { label: '맨 앞으로', value: 'front', action: () => { selectedElements = [element]; bringToFront(); } },
                { label: '맨 뒤로', value: 'back', action: () => { selectedElements = [element]; sendToBack(); } },
                { label: '복사하기', value: 'copy', action: () => { 
                    copiedElements = selectedElements.map(el => {
                        const copy = JSON.parse(JSON.stringify(el));
                        if (copy.type === 'line') {
                            copy.startShapeId = el.startShape ? el.startShape.id : null;
                            copy.endShapeId = el.endShape ? el.endShape.id : null;
                        }
                        return copy;
                    });
                    console.log('Copied via Context Menu:', copiedElements);
                } }
            ];
            options.forEach(option => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.textContent = option.label;
                item.addEventListener('click', () => {
                    option.action();
                    contextMenu.remove();
                    contextMenu = null;
                    drawDiagram();
                });
                contextMenu.appendChild(item);
            });
        } else if (copiedElements.length > 0) {
            const pasteOption = {
                label: '붙여넣기',
                value: 'paste',
                action: () => {
                    const pastedElements = pasteElements(x, y);
                    elements.push(...pastedElements);
                    selectedElements = pastedElements;
                    updatePropertiesPanel();
                    drawDiagram();
                }
            };
            const item = document.createElement('div');
            item.className = 'context-menu-item';
            item.textContent = pasteOption.label;
            item.addEventListener('click', () => {
                pasteOption.action();
                contextMenu.remove();
                contextMenu = null;
            });
            contextMenu.appendChild(item);
        }
        if (contextMenu.children.length > 0) {
            document.body.appendChild(contextMenu);
        }
    }

    function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;

        if (e.button === 1) {
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
            return;
        }
        if (e.button === 2) return;

        if (connectingShape) {
            const targetShape = getElementAt(x, y);
            if (targetShape && targetShape !== connectingShape && targetShape.type !== 'line' && targetShape.type !== 'text') {
                const newLine = createNewLine(connectingShape, targetShape, selectedLineType);
                elements.push(newLine);
                selectedElements = [newLine];
                connectingShape = null;
                selectedLineType = null;
                updatePropertiesPanel();
                drawDiagram();
            }
            return;
        }

        if (currentTool === 'select') {
            resizeHandle = getResizeHandle(x, y);
            if (resizeHandle && selectedElements.length > 0) {
                isDrawing = true;
                resizing = true;
                startX = x;
                startY = y;
                return;
            }

            const lineEndpoint = getLineEndpointAt(x, y);
            if (lineEndpoint) {
                isDrawing = true;
                movingLineEndpoint = lineEndpoint;
                startX = x;
                startY = y;
                return;
            }

            const element = getElementAt(x, y);
            if (element && selectedElements.includes(element)) {
                isDrawing = true;
                resizing = false;
                startX = x;
                startY = y;
                selectedElements.forEach(el => {
                    if (el.type !== 'line') {
                        el.dragOffsetX = x - el.x;
                        el.dragOffsetY = y - el.y;
                    }
                });
                updatePropertiesPanel();
            } else if (element) {
                if (!e.ctrlKey) selectedElements = [];
                if (!selectedElements.includes(element)) selectedElements.push(element);
                isDrawing = true;
                resizing = false;
                startX = x;
                startY = y;
                selectedElements.forEach(el => {
                    if (el.type !== 'line') {
                        el.dragOffsetX = x - el.x;
                        el.dragOffsetY = y - el.y;
                    }
                });
                updatePropertiesPanel();
            } else {
                if (!e.ctrlKey) selectedElements = [];
                isDrawing = true;
                resizing = false;
                startX = x;
                startY = y;
                selectionRect = { x: x, y: y, width: 0, height: 0 };
            }
        } else {
            isDrawing = true;
            startX = x;
            startY = y;
            tempElement = createNewElement(currentTool, x, y, 0, 0);
        }
        drawDiagram();
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - offsetX) / scale;
        const y = (e.clientY - rect.top - offsetY) / scale;

        mouseX = x;
        mouseY = y;
        document.getElementById('coordinates').textContent = `X: ${Math.round(x)}, Y: ${Math.round(y)}`;

        if (currentTool === 'select' && !isDrawing) {
            const handle = getResizeHandle(x, y);
            if (handle) {
                if (handle === 'tl' || handle === 'br') {
                    canvas.style.cursor = 'nwse-resize';
                } else if (handle === 'tr' || handle === 'bl') {
                    canvas.style.cursor = 'nesw-resize';
                }
            } else if (getLineEndpointAt(x, y)) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        if (isPanning) {
            const dx = (e.clientX - panStartX) / scale;
            const dy = (e.clientY - panStartY) / scale;
            offsetX += dx * scale;
            offsetY += dy * scale;
            panStartX = e.clientX;
            panStartY = e.clientY;
            drawDiagram();
            return;
        }

        if (!isDrawing) return;

        if (currentTool === 'select') {
            if (movingLineEndpoint) {
                const targetShape = getElementAt(x, y);
                if (targetShape && targetShape.type !== 'line' && targetShape.type !== 'text') {
                    if (movingLineEndpoint.endpoint === 'start') {
                        movingLineEndpoint.line.startShape = targetShape;
                        movingLineEndpoint.line.startShapeId = targetShape.id;
                    } else {
                        movingLineEndpoint.line.endShape = targetShape;
                        movingLineEndpoint.line.endShapeId = targetShape.id;
                    }
                }
            } else if (resizing && selectedElements.length > 0) {
                resizeElements(x, y);
            } else if (selectionRect) {
                selectionRect.width = x - startX;
                selectionRect.height = y - startY;
                selectElementsInRect();
            } else if (selectedElements.length > 0) {
                const dx = x - startX;
                const dy = y - startY;
                selectedElements.forEach(element => {
                    if (element.type !== 'line') {
                        element.x = element.x + dx;
                        element.y = element.y + dy;
                    }
                });

                if (isValidGroup(selectedElements)) {
                    const bounds = getSelectionBounds();
                    const centerX = bounds.x + bounds.width / 2;
                    const centerY = bounds.y + bounds.height / 2;

                    let intersectedLine = null;
                    for (let i = 0; i < elements.length; i++) {
                        const el = elements[i];
                        if (el.type === 'line' && el.startShape && el.endShape && !selectedElements.includes(el)) {
                            const edges = getClosestEdge(el.startShape, el.endShape);
                            const distance = distanceToLine(centerX, centerY, edges.start.x, edges.start.y, edges.end.x, edges.end.y);
                            if (distance < 20) {
                                intersectedLine = el;
                                break;
                            }
                        }
                    }

                    selectedElements.forEach(element => {
                        if (element.type !== 'line') {
                            if (intersectedLine) {
                                element.tempFillColor = '#90caf9';
                            } else {
                                delete element.tempFillColor;
                            }
                        }
                    });
                } else {
                    selectedElements.forEach(element => {
                        if (element.type !== 'line') {
                            let intersectedLine = null;
                            for (let i = 0; i < elements.length; i++) {
                                const el = elements[i];
                                if (el.type === 'line' && el.startShape && el.endShape && el !== element) {
                                    const edges = getClosestEdge(el.startShape, el.endShape);
                                    const distance = distanceToLine(
                                        element.x + element.width / 2,
                                        element.y + element.height / 2,
                                        edges.start.x, edges.start.y,
                                        edges.end.x, edges.end.y
                                    );
                                    if (distance < 20) {
                                        intersectedLine = el;
                                        break;
                                    }
                                }
                            }
                            if (intersectedLine) {
                                element.tempFillColor = '#90caf9';
                            } else {
                                delete element.tempFillColor;
                            }
                        }
                    });
                }

                startX = x;
                startY = y;
                updatePropertiesPanel();
            }
        } else if (tempElement) {
            tempElement.width = x - startX;
            tempElement.height = y - startY;
        }
        drawDiagram();
    }

    function handleMouseUp(e) {
		const rect = canvas.getBoundingClientRect();
		const x = (e.clientX - rect.left - offsetX) / scale;
		const y = (e.clientY - rect.top - offsetY) / scale;

		if (e.button === 1) {
			isPanning = false;
			canvas.style.cursor = 'default';
			return;
		}

		if (isDrawing && currentTool !== 'select' && tempElement) {
			tempElement.width = x - startX;
			tempElement.height = y - startY;

			if (tempElement.width < 0) {
				tempElement.x += tempElement.width;
				tempElement.width = Math.abs(tempElement.width);
			}
			if (tempElement.height < 0) {
				tempElement.y += tempElement.height;
				tempElement.height = Math.abs(tempElement.height);
			}

			if (tempElement.type === 'text') {
				tempElement.text = '텍스트';
			}

			elements.push(tempElement);
			selectedElements = [tempElement];
			updatePropertiesPanel();

			if (creationMode === 'single') {
				document.querySelectorAll('.toolbar .tool-btn').forEach(b => b.classList.remove('active'));
				document.getElementById('select-tool').classList.add('active');
				currentTool = 'select';
			}
		} else if (currentTool === 'select' && selectionRect) {
			selectionRect = null;
		} else if (currentTool === 'select') {
			if (selectedElements.length > 0) {
				// 그룹 삽입 처리
				if (isValidGroup(selectedElements)) {
					const bounds = getSelectionBounds();
					const centerX = bounds.x + bounds.width / 2;
					const centerY = bounds.y + bounds.height / 2;

					let intersectedLine = null;
					for (let i = 0; i < elements.length; i++) {
						const el = elements[i];
						if (el.type === 'line' && el.startShape && el.endShape && !selectedElements.includes(el)) {
							const edges = getClosestEdge(el.startShape, el.endShape);
							const distance = distanceToLine(centerX, centerY, edges.start.x, edges.start.y, edges.end.x, edges.end.y);
							if (distance < 20) {
								intersectedLine = el;
								break;
							}
						}
					}

					if (intersectedLine) {
						insertGroupIntoLine(selectedElements, intersectedLine);
						selectedElements = []; // 그룹 삽입 후 선택 해제
						updatePropertiesPanel();
					} else {
						selectedElements.forEach(element => {
							if (element.type !== 'line') {
								delete element.tempFillColor;
							}
						});
					}
				} else if (selectedElements.length === 1 && selectedElements[0].type !== 'line') {
					// 단일 도형 삽입 처리
					const movedShape = selectedElements[0];
					let intersectedLine = null;
					for (let i = 0; i < elements.length; i++) {
						const element = elements[i];
						if (element.type === 'line' && element.startShape && element.endShape && element !== movedShape) {
							const edges = getClosestEdge(element.startShape, element.endShape);
							const distance = distanceToLine(
								movedShape.x + movedShape.width / 2,
								movedShape.y + movedShape.height / 2,
								edges.start.x, edges.start.y,
								edges.end.x, edges.end.y
							);
							if (distance < 20) {
								intersectedLine = element;
								break;
							}
						}
					}

					if (intersectedLine) {
						const startShape = intersectedLine.startShape;
						const endShape = intersectedLine.endShape;
						const lineType = intersectedLine.lineType;
						const strokeColor = intersectedLine.strokeColor;
						const strokeWidth = intersectedLine.strokeWidth;

						elements.push({
							id: Date.now() + Math.random(),
							type: 'line',
							startShape: startShape,
							endShape: movedShape,
							startShapeId: startShape.id,
							endShapeId: movedShape.id,
							lineType: lineType,
							strokeColor: strokeColor,
							strokeWidth: strokeWidth
						});

						elements.push({
							id: Date.now() + Math.random(),
							type: 'line',
							startShape: movedShape,
							endShape: endShape,
							startShapeId: movedShape.id,
							endShapeId: endShape.id,
							lineType: lineType,
							strokeColor: strokeColor,
							strokeWidth: strokeWidth
						});

						const index = elements.indexOf(intersectedLine);
						if (index !== -1) elements.splice(index, 1);

						delete movedShape.tempFillColor;
						selectedElements = []; // 단일 도형 삽입 후 선택 해제
						updatePropertiesPanel();
					} else {
						delete movedShape.tempFillColor;
					}
				} else {
					// 그룹 삽입 조건에 맞지 않거나 단일 도형이 아닌 경우
					selectedElements.forEach(element => {
						if (element.type !== 'line') {
							delete element.tempFillColor;
						}
					});
				}
			}
		}

		isDrawing = false;
		resizing = false;
		movingLineEndpoint = null;
		tempElement = null;
		drawDiagram();
	}

    function handleWheel(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        const newScale = scale * zoomFactor;

        if (newScale < 0.2 || newScale > 5) return;

        const worldXBefore = (mouseX - offsetX) / scale;
        const worldYBefore = (mouseY - offsetY) / scale;

        scale = newScale;

        offsetX = mouseX - worldXBefore * scale;
        offsetY = mouseY - worldYBefore * scale;

        drawDiagram();
    }

    function selectElementsInRect() {
        const rectX = Math.min(startX, startX + selectionRect.width);
        const rectY = Math.min(startY, startY + selectionRect.height);
        const rectWidth = Math.abs(selectionRect.width);
        const rectHeight = Math.abs(selectionRect.height);

        elements.forEach(element => {
            if (element.type === 'line' && element.startShape && element.endShape) {
                const edges = getClosestEdge(element.startShape, element.endShape);
                const startInRect = (
                    edges.start.x >= rectX && edges.start.x <= rectX + rectWidth &&
                    edges.start.y >= rectY && edges.start.y <= rectY + rectHeight
                );
                const endInRect = (
                    edges.end.x >= rectX && edges.end.x <= rectX + rectWidth &&
                    edges.end.y >= rectY && edges.end.y <= rectY + rectHeight
                );
                const intersects = lineIntersectsRect(
                    edges.start.x, edges.start.y, edges.end.x, edges.end.y,
                    rectX, rectY, rectX + rectWidth, rectY + rectHeight
                );
                if (startInRect || endInRect || intersects) {
                    if (!selectedElements.includes(element)) selectedElements.push(element);
                }
            } else if (element.type !== 'line') {
                const inRect = (
                    element.x >= rectX && element.x + element.width <= rectX + rectWidth &&
                    element.y >= rectY && element.y + element.height <= rectY + rectHeight
                );
                if (inRect && !selectedElements.includes(element)) {
                    selectedElements.push(element);
                }
            }
        });
    }

    function lineIntersectsRect(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {
        const left = Math.min(rx1, rx2);
        const right = Math.max(rx1, rx2);
        const top = Math.min(ry1, ry2);
        const bottom = Math.max(ry1, ry2);

        // 선분이 사각형의 경계와 교차하는지 확인
        const denom = (x1 - x2) * (top - bottom) - (y1 - y2) * (left - right);
        if (denom === 0) return false; // 평행한 경우 교차하지 않음

        const t = ((x1 - left) * (top - bottom) - (y1 - top) * (left - right)) / denom;
        const u = -((x1 - x2) * (y1 - top) - (y1 - y2) * (x1 - left)) / denom;

        return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    function getElementAt(x, y) {
        for (let i = elements.length - 1; i >= 0; i--) {
            const el = elements[i];
            if (el.type === 'line' && el.startShape && el.endShape) {
                const edges = getClosestEdge(el.startShape, el.endShape);
                const dist = distanceToLine(x, y, edges.start.x, edges.start.y, edges.end.x, edges.end.y);
                if (dist < 5 / scale) return el;
            } else if (el.type !== 'line') {
                if (x >= el.x && x <= el.x + el.width && y >= el.y && y <= el.y + el.height) {
                    return el;
                }
            }
        }
        return null;
    }

    function distanceToLine(x, y, x1, y1, x2, y2) {
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        const dx = x - xx;
        const dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function getResizeHandle(x, y) {
        if (selectedElements.length !== 1 || selectedElements[0].type === 'line') return null;
        const el = selectedElements[0];
        const handleSize = 10 / scale;
        const handles = {
            'tl': { x: el.x, y: el.y },
            'tr': { x: el.x + el.width, y: el.y },
            'bl': { x: el.x, y: el.y + el.height },
            'br': { x: el.x + el.width, y: el.y + el.height }
        };
        for (const [key, pos] of Object.entries(handles)) {
            if (Math.abs(x - pos.x) < handleSize / 2 && Math.abs(y - pos.y) < handleSize / 2) {
                return key;
            }
        }
        return null;
    }

    function getLineEndpointAt(x, y) {
        if (selectedElements.length !== 1 || selectedElements[0].type !== 'line') return null;
        const line = selectedElements[0];
        if (!line.startShape || !line.endShape) return null;
        const edges = getClosestEdge(line.startShape, line.endShape);
        const handleSize = 10 / scale;
        if (Math.hypot(x - edges.start.x, y - edges.start.y) < handleSize / 2) {
            return { line, endpoint: 'start' };
        }
        if (Math.hypot(x - edges.end.x, y - edges.end.y) < handleSize / 2) {
            return { line, endpoint: 'end' };
        }
        return null;
    }

    function resizeElements(x, y) {
        const dx = x - startX;
        const dy = y - startY;
        const el = selectedElements[0];
        switch (resizeHandle) {
            case 'tl':
                el.x += dx;
                el.y += dy;
                el.width -= dx;
                el.height -= dy;
                break;
            case 'tr':
                el.y += dy;
                el.width += dx;
                el.height -= dy;
                break;
            case 'bl':
                el.x += dx;
                el.width -= dx;
                el.height += dy;
                break;
            case 'br':
                el.width += dx;
                el.height += dy;
                break;
        }
        if (el.width < 10) el.width = 10;
        if (el.height < 10) el.height = 10;
        startX = x;
        startY = y;
        updatePropertiesPanel();
    }

    function getSelectionBounds() {
        if (selectedElements.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        selectedElements.forEach(el => {
            if (el.type === 'line' && el.startShape && el.endShape) {
                const edges = getClosestEdge(el.startShape, el.endShape);
                minX = Math.min(minX, edges.start.x, edges.end.x);
                minY = Math.min(minY, edges.start.y, edges.end.y);
                maxX = Math.max(maxX, edges.start.x, edges.end.x);
                maxY = Math.max(maxY, edges.start.y, edges.end.y);
            } else if (el.type !== 'line') {
                minX = Math.min(minX, el.x);
                minY = Math.min(minY, el.y);
                maxX = Math.max(maxX, el.x + el.width);
                maxY = Math.max(maxY, el.y + el.height);
            }
        });
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function createNewElement(type, x, y, width, height) {
		const defaults = {
			fillColor: document.getElementById('fill-color-preview').style.backgroundColor || '#ffffff',
			strokeColor: document.getElementById('stroke-color-preview').style.backgroundColor || '#000000',
			strokeWidth: parseInt(document.getElementById('stroke-width').value),
			strokeStyle: document.getElementById('stroke-style').value,
			defaultFontSize: parseInt(document.getElementById('font-size').value),
			defaultTextColor: document.getElementById('text-color-preview').style.backgroundColor || '#000000'
		};
		return {
			id: Date.now() + Math.random(),
			type: type,
			x: x,
			y: y,
			width: width,
			height: height,
			fillColor: defaults.fillColor,
			strokeColor: defaults.strokeColor,
			strokeWidth: defaults.strokeWidth,
			strokeStyle: defaults.strokeStyle,
			defaultFontSize: defaults.defaultFontSize,
			defaultTextColor: defaults.defaultTextColor,
			textFragments: type === 'text' ? [{
				content: '텍스트',
				style: {
					color: defaults.defaultTextColor,
					fontSize: defaults.defaultFontSize,
					bold: false,
					italic: false,
					underline: false
				}
			}] : []
		};
	}

    function createNewLine(startShape, endShape, lineType) {
		return {
			id: Date.now() + Math.random(),
			type: 'line',
			startShape: startShape,
			endShape: endShape,
			startShapeId: startShape.id,
			endShapeId: endShape.id,
			lineType: lineType,
			strokeColor: document.getElementById('stroke-color-preview').style.backgroundColor || '#000000',
			strokeWidth: parseInt(document.getElementById('stroke-width').value),
			strokeStyle: 'solid' // 기본값을 'solid'로 고정
		};
	}
	
    // updateSelectedElement 수정: 색상 입력 제거
	function updateSelectedElement() {
		if (selectedElements.length === 0) return;
		selectedElements.forEach(element => {
			if (element.type !== 'line') {
				element.strokeWidth = parseInt(document.getElementById('stroke-width').value);
				element.strokeStyle = document.getElementById('stroke-style').value;
				element.x = parseInt(document.getElementById('pos-x').value);
				element.y = parseInt(document.getElementById('pos-y').value);
				element.width = parseInt(document.getElementById('pos-width').value);
				element.height = parseInt(document.getElementById('pos-height').value);
				if (element.textFragments && element.textFragments.length > 0) {
					const newText = document.getElementById('text-content').value;
					const lines = newText.split('\n');
					element.textFragments = element.textFragments.map((fragment, index) => {
						const newContent = lines[index] !== undefined ? lines[index] : fragment.content;
						return {
							content: newContent,
							style: {
								color: fragment.style.color, // 색상은 applyColor에서 변경됨
								fontSize: parseInt(document.getElementById('font-size').value),
								bold: document.getElementById('font-bold').checked,
								italic: document.getElementById('font-italic').checked,
								underline: document.getElementById('font-underline').checked
							}
						};
					});
					for (let i = element.textFragments.length; i < lines.length; i++) {
						element.textFragments.push({
							content: lines[i],
							style: {
								color: element.defaultTextColor || '#000000',
								fontSize: parseInt(document.getElementById('font-size').value),
								bold: document.getElementById('font-bold').checked,
								italic: document.getElementById('font-italic').checked,
								underline: document.getElementById('font-underline').checked
							}
						});
					}
				}
			} else {
				element.strokeWidth = parseInt(document.getElementById('stroke-width').value);
				element.strokeStyle = document.getElementById('stroke-style').value;
			}
		});
		drawDiagram();
	}

	// updatePropertiesPanel 수정: 색상 미리보기 업데이트
	function updatePropertiesPanel() {
		if (selectedElements.length === 0) {
			document.getElementById('shape-properties').classList.remove('hidden');
			document.getElementById('text-properties').classList.add('hidden');
			document.getElementById('fill-color-preview').style.backgroundColor = '#ffffff';
			document.getElementById('stroke-color-preview').style.backgroundColor = '#000000';
			document.getElementById('stroke-width').value = 2;
			document.getElementById('stroke-style').value = 'solid';
			document.getElementById('pos-x').value = 0;
			document.getElementById('pos-y').value = 0;
			document.getElementById('pos-width').value = 100;
			document.getElementById('pos-height').value = 80;
			document.getElementById('text-content').value = '텍스트';
			document.getElementById('font-size').value = 16;
			document.getElementById('text-color-preview').style.backgroundColor = '#000000';
			document.getElementById('font-bold').checked = false;
			document.getElementById('font-italic').checked = false;
			document.getElementById('font-underline').checked = false;
		} else if (selectedElements.length === 1) {
			const element = selectedElements[0];
			document.getElementById('shape-properties').classList.remove('hidden');
			document.getElementById('fill-color-preview').style.backgroundColor = element.fillColor || '#ffffff';
			document.getElementById('stroke-color-preview').style.backgroundColor = element.strokeColor || '#000000';
			document.getElementById('stroke-width').value = element.strokeWidth || 2;
			document.getElementById('stroke-style').value = element.strokeStyle || 'solid';
			document.getElementById('pos-x').value = Math.round(element.x);
			document.getElementById('pos-y').value = Math.round(element.y);
			document.getElementById('pos-width').value = Math.round(element.width);
			document.getElementById('pos-height').value = Math.round(element.height);
			if (element.type !== 'line') {
				document.getElementById('text-properties').classList.remove('hidden');
				if (element.textFragments && element.textFragments.length > 0) {
					const fragment = element.textFragments[0];
					document.getElementById('text-content').value = element.textFragments.map(f => f.content).join('\n');
					document.getElementById('font-size').value = fragment.style.fontSize || 16;
					document.getElementById('text-color-preview').style.backgroundColor = fragment.style.color || '#000000';
					document.getElementById('font-bold').checked = fragment.style.bold || false;
					document.getElementById('font-italic').checked = fragment.style.italic || false;
					document.getElementById('font-underline').checked = fragment.style.underline || false;
				} else {
					document.getElementById('text-content').value = '';
					document.getElementById('font-size').value = element.defaultFontSize || 16;
					document.getElementById('text-color-preview').style.backgroundColor = element.defaultTextColor || '#000000';
					document.getElementById('font-bold').checked = false;
					document.getElementById('font-italic').checked = false;
					document.getElementById('font-underline').checked = false;
				}
			} else {
				document.getElementById('text-properties').classList.add('hidden');
			}
		} else {
			document.getElementById('shape-properties').classList.remove('hidden');
			document.getElementById('text-properties').classList.add('hidden');
			const bounds = getSelectionBounds();
			document.getElementById('pos-x').value = Math.round(bounds.x);
			document.getElementById('pos-y').value = Math.round(bounds.y);
			document.getElementById('pos-width').value = Math.round(bounds.width);
			document.getElementById('pos-height').value = Math.round(bounds.height);
		}
	}

    function bringToFront() {
        if (selectedElements.length === 0) return;
        selectedElements.forEach(element => {
            const index = elements.indexOf(element);
            if (index !== -1) {
                elements.splice(index, 1);
                elements.push(element);
            }
        });
        drawDiagram();
    }

    function sendToBack() {
        if (selectedElements.length === 0) return;
        selectedElements.forEach(element => {
            const index = elements.indexOf(element);
            if (index !== -1) {
                elements.splice(index, 1);
                elements.unshift(element);
            }
        });
        drawDiagram();
    }

    function saveDiagram() {
        const data = JSON.stringify(elements.map(el => {
            const copy = { ...el };
            if (copy.type === 'line') {
                copy.startShapeId = el.startShape ? el.startShape.id : null;
                copy.endShapeId = el.endShape ? el.endShape.id : null;
                delete copy.startShape;
                delete copy.endShape;
            }
            delete copy.dragOffsetX;
            delete copy.dragOffsetY;
            delete copy.tempFillColor;
            return copy;
        }));
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `diagram-${new Date().toISOString().slice(0,10)}.json`;
        link.click();
        URL.revokeObjectURL(url);
    }

    function loadDiagram() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const data = JSON.parse(event.target.result);
                elements = data.map(el => {
                    const element = { ...el };
                    if (element.type === 'line') {
                        element.startShape = elements.find(e => e.id === element.startShapeId) || null;
                        element.endShape = elements.find(e => e.id === element.endShapeId) || null;
                    }
                    return element;
                });
                selectedElements = [];
                updatePropertiesPanel();
                drawDiagram();
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function pasteElements(x, y) {
        const pasted = [];
        const idMap = new Map();
        const bounds = getCopiedElementsBounds();
        const offsetX = x - bounds.x - bounds.width / 2;
        const offsetY = y - bounds.y - bounds.height / 2;

        copiedElements.forEach(el => {
            const copy = JSON.parse(JSON.stringify(el));
            copy.id = Date.now() + Math.random();
            idMap.set(el.id, copy.id);
            if (copy.type !== 'line') {
                copy.x += offsetX;
                copy.y += offsetY;
            }
            pasted.push(copy);
        });

        pasted.forEach(el => {
            if (el.type === 'line') {
                el.startShape = pasted.find(e => e.id === idMap.get(el.startShapeId)) || null;
                el.endShape = pasted.find(e => e.id === idMap.get(el.endShapeId)) || null;
            }
        });

        return pasted;
    }

    function getCopiedElementsBounds() {
        if (copiedElements.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        copiedElements.forEach(el => {
            if (el.type === 'line' && el.startShapeId && el.endShapeId) {
                const startEl = copiedElements.find(e => e.id === el.startShapeId);
                const endEl = copiedElements.find(e => e.id === el.endShapeId);
                if (startEl) {
                    minX = Math.min(minX, startEl.x);
                    minY = Math.min(minY, startEl.y);
                    maxX = Math.max(maxX, startEl.x + startEl.width);
                    maxY = Math.max(maxY, startEl.y + startEl.height);
                }
                if (endEl) {
                    minX = Math.min(minX, endEl.x);
                    minY = Math.min(minY, endEl.y);
                    maxX = Math.max(maxX, endEl.x + endEl.width);
                    maxY = Math.max(maxY, endEl.y + endEl.height);
                }
            } else if (el.type !== 'line') {
                minX = Math.min(minX, el.x);
                minY = Math.min(minY, el.y);
                maxX = Math.max(maxX, el.x + el.width);
                maxY = Math.max(maxY, el.y + el.height);
            }
        });
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    // 키보드 단축키 추가
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'c') {
            copiedElements = selectedElements.map(el => {
                const copy = JSON.parse(JSON.stringify(el));
                if (copy.type === 'line') {
                    copy.startShapeId = el.startShape ? el.startShape.id : null;
                    copy.endShapeId = el.endShape ? el.endShape.id : null;
                }
                return copy;
            });
            console.log('Copied via Ctrl+C:', copiedElements);
        } else if (e.ctrlKey && e.key === 'v' && copiedElements.length > 0) {
            const pastedElements = pasteElements(mouseX, mouseY);
            elements.push(...pastedElements);
            selectedElements = pastedElements;
            updatePropertiesPanel();
            drawDiagram();
        } else if (e.key === 'Delete' && selectedElements.length > 0) {
            elements = elements.filter(el => !selectedElements.includes(el));
            selectedElements = [];
            updatePropertiesPanel();
            drawDiagram();
        }
    });
});
    </script>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4624141391435876"
	     crossorigin="anonymous"></script>
	<!-- [디스플레이, 반응형] 하단광고 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-4624141391435876"
	     data-ad-slot="5073984195"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
	     (adsbygoogle = window.adsbygoogle || []).push({});
	</script>
</body>
</html>
